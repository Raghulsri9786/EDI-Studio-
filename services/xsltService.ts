
import { MappingRule, ErpSchema } from '../types';

export const generateXslt = (schema: ErpSchema, rules: MappingRule[]): string => {
  const date = new Date().toISOString();
  
  let xslt = `<?xml version="1.0" encoding="UTF-8"?>
<!-- 
  Auto-Generated XSLT for ${schema.transactionType} 
  Generated by EDI Studio on ${date}
  Target Schema: ${schema.name}
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="xml" indent="yes"/>

  <!-- Root Template -->
  <xsl:template match="/">
    <${schema.root.name}>
`;

  // Helper to find rule for a target path
  const findRule = (targetPath: string) => rules.find(r => r.targetPath === targetPath);

  // Recursive function to build XML structure based on Schema
  const buildXml = (node: any, pathPrefix: string, indent: string) => {
    // Current Path in Schema
    const currentPath = pathPrefix ? `${pathPrefix}/${node.name}` : node.name;
    const rule = findRule(currentPath);

    if (node.children && node.children.length > 0) {
      // It's a container (Object/Array)
      xslt += `${indent}<${node.name}>\n`;
      
      // If array, we might want to loop in XSLT if the mapping source implies a loop
      // For simplicity, we just recurse
      node.children.forEach((child: any) => {
        buildXml(child, currentPath, indent + "  ");
      });
      
      xslt += `${indent}</${node.name}>\n`;
    } else {
      // Leaf Node (Field)
      if (rule) {
        // We have a mapping!
        // Source Path format assumed: SEGMENT/INDEX e.g. "BEG/03"
        // Convert "BEG/03" to XSLT path "BEG/BEG03" assuming simple XML parser
        const parts = rule.sourcePath.split('/');
        const segment = parts[0];
        const element = parts[1];
        const xpath = `//${segment}/${segment}${element}`; // Simple heuristic

        xslt += `${indent}<${node.name}>\n`;
        xslt += `${indent}  <xsl:value-of select="${xpath}"/>\n`;
        xslt += `${indent}</${node.name}>\n`;
      } else {
        // No mapping, output empty tag or comment
        xslt += `${indent}<!-- <${node.name}> Unmapped </${node.name}> -->\n`;
      }
    }
  };

  if (schema.root.children) {
    schema.root.children.forEach(child => {
      buildXml(child, schema.root.name, "      ");
    });
  }

  xslt += `    </${schema.root.name}>
  </xsl:template>
</xsl:stylesheet>`;

  return xslt;
};
